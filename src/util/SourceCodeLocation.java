package util;

import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;

/**
 * The class of the location in the source code. A location of the source code is determined by the line number
 * column, and the source file name.
 * @author Zhou Xiaocong
 * @since 2012/12/26
 * @version 1.0
 *
 */
public class SourceCodeLocation implements Comparable<SourceCodeLocation> {
	private int lineNumber = -1;		// The line number in the source code file
	private int column = -1;			// The column in the source code file
	private String fullFileName = null;	// The full file name (i.e. including the path of the file)

	public static final String FILE_NAME_BEGINNER = "@";
	public static final String LINE_COLUMN_SPLITTER = ":";
	
	/**
	 * @param lineNo: The line number in the source code file
	 * @param col: The column in the source code file
	 * @param fullFileName: The full file name (i.e. including the path of the file).
	 */
	public SourceCodeLocation(int lineNo, int col, String fullFileName) {
		lineNumber = lineNo;
		column = col;
		this.fullFileName = fullFileName;
	}

	public int getLineNumber() {
		return lineNumber;
	}

	public int getColumn() {
		return column;
	}

	public String getFullFileName() {
		return fullFileName;
	}
	
	@Override
	public String toString() {
		return "" + lineNumber + LINE_COLUMN_SPLITTER + column;
	}
	
	public String toFullString() {
		return lineNumber + LINE_COLUMN_SPLITTER + column + FILE_NAME_BEGINNER + fullFileName;
	}

	public String getUniqueId() {
		return lineNumber + LINE_COLUMN_SPLITTER + column + FILE_NAME_BEGINNER + fullFileName;
	}
	
	public static String getFullFileNameFromId(String id) {
		int indexOfAt = id.indexOf(FILE_NAME_BEGINNER);
		if (indexOfAt < 0) return null;
		return id.substring(indexOfAt+1);
	}

	/**
	 * Get a location object from a location string. We assume that the locationString is a full string of location
	 * generated by the method SourceCodeLocation.toFullString(), that it, it has the format as "lineNo:Column@fileName";  
	 */
	public static SourceCodeLocation getLocation(String locationString) {
		int colonIndex = locationString.indexOf(LINE_COLUMN_SPLITTER);
		int atIndex = locationString.indexOf(FILE_NAME_BEGINNER);
		
		if (colonIndex < 0 || atIndex < 0 || atIndex <= colonIndex || atIndex >= locationString.length()) 
			throw new AssertionError("Can not find : or @ in the location string, or illegal location string [" + locationString + "]");

		try {
			String lineString = locationString.substring(0, colonIndex);
			int lineNumber = Integer.parseInt(lineString);
			
			String colString = locationString.substring(colonIndex+1, atIndex);
			int column = Integer.parseInt(colString);
			
			String fileName = locationString.substring(atIndex+1, locationString.length());
			return new SourceCodeLocation(lineNumber, column, fileName);
		} catch (NumberFormatException exc) {
			throw new AssertionError("Illegal location string [" + locationString + "]");
		}
	}
	
	@Override
	public int compareTo(SourceCodeLocation other) {
		if (this == other) return 0;
		
		if (fullFileName == null) {
			if (other.fullFileName != null) return -1;
		} else {
			if (other.fullFileName == null) return 1;
			else {
				int result = fullFileName.compareTo(other.fullFileName);
				if (result != 0) return result;
			}
		}
		if (lineNumber != other.lineNumber) return (lineNumber - other.lineNumber);
		return column - other.column;
	}
	
	/**
	 * Check the current location is between start and end or not
	 */
	public boolean isBetween(SourceCodeLocation start, SourceCodeLocation end) {
		if (start == null || end == null) return false;
		if (!fullFileName.equals(start.fullFileName) || !fullFileName.equals(end.fullFileName))return false;
		if (lineNumber < start.lineNumber) return false;
		if (lineNumber > end.lineNumber) return false;
		if (lineNumber == start.lineNumber && column < start.column) return false;
		if (lineNumber == end.lineNumber && column > end.column) return false; 
		return true;
	}
	
	@Override
	public boolean equals(Object other) {
		if (this == other) return true;
		if (other == null) return false;
		if (!(other instanceof SourceCodeLocation)) return false;
		SourceCodeLocation otherLocation = (SourceCodeLocation)other;
		
		if (fullFileName == null) {
			if (otherLocation.fullFileName != null) return false;
		} else {
			if (otherLocation.fullFileName == null) return false;
			if (!fullFileName.equals(otherLocation.fullFileName)) return false;
		}
		if (lineNumber != otherLocation.lineNumber || column != otherLocation.column) return false;
		return true;
	}
	
	@Override
	public int hashCode() {
		int result = 17;
		if (fullFileName != null) result = fullFileName.hashCode();
		result = 31 * result + lineNumber;
		result = 31 * result + column;
		return result;
	}
	
	public static SourceCodeLocation getStartLocation(ASTNode node, CompilationUnit root, String compilationUnitFileName) {
		int position = node.getStartPosition();
		int lineNumber = root.getLineNumber(position);
		int column = root.getColumnNumber(position);
		
		if (lineNumber < 0 || column < 0) 
			throw new AssertionError("Get illegal linenumber(" + lineNumber + ") or column(" + column + ") for AST node: " + node.toString());
		
		return new SourceCodeLocation(lineNumber, column, compilationUnitFileName);
	}

	public static SourceCodeLocation getEndLocation(ASTNode node, CompilationUnit root, String compilationUnitFileName) {
		int position = node.getStartPosition() + node.getLength();
		int lineNumber = root.getLineNumber(position);
		int column = root.getColumnNumber(position);
		
		if (lineNumber < 0 || column < 0) 
			throw new AssertionError("Get illegal linenumber(" + lineNumber + ") or column(" + column + ") for AST node: " + node.toString());
		return new SourceCodeLocation(lineNumber, column, compilationUnitFileName);
	}

}
