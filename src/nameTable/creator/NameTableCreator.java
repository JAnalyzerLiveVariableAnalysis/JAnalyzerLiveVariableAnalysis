package nameTable.creator;

import java.io.File;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.AbstractTypeDeclaration;
import org.eclipse.jdt.core.dom.Block;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.EnumConstantDeclaration;
import org.eclipse.jdt.core.dom.EnumDeclaration;
import org.eclipse.jdt.core.dom.Expression;
import org.eclipse.jdt.core.dom.FieldDeclaration;
import org.eclipse.jdt.core.dom.ImportDeclaration;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.Name;
import org.eclipse.jdt.core.dom.PackageDeclaration;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.Statement;
import org.eclipse.jdt.core.dom.Type;
import org.eclipse.jdt.core.dom.TypeDeclaration;
import org.eclipse.jdt.core.dom.VariableDeclaration;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;

import util.SourceCodeLocation;
import util.SourceCodeParser;
import nameTable.NameTableManager;
import nameTable.nameDefinition.AutoGeneratedConstructor;
import nameTable.nameDefinition.DetailedTypeDefinition;
import nameTable.nameDefinition.EnumConstantDefinition;
import nameTable.nameDefinition.EnumTypeDefinition;
import nameTable.nameDefinition.FieldDefinition;
import nameTable.nameDefinition.MethodDefinition;
import nameTable.nameDefinition.NameDefinitionKind;
import nameTable.nameDefinition.PackageDefinition;
import nameTable.nameDefinition.SimpleTypeDefinition;
import nameTable.nameDefinition.VariableDefinition;
import nameTable.nameReference.NameReference;
import nameTable.nameReference.NameReferenceLabel;
import nameTable.nameReference.PackageReference;
import nameTable.nameReference.ParameterizedTypeReference;
import nameTable.nameReference.QualifiedTypeReference;
import nameTable.nameReference.TypeReference;
import nameTable.nameScope.CompilationUnitScope;
import nameTable.nameScope.LocalScope;
import nameTable.nameScope.NameScope;
import nameTable.nameScope.NameScopeKind;
import nameTable.nameScope.SystemScope;

/**
 * Create all name definitions and name references of all Java source code files under a system path
 * @author Zhou Xiaocong
 * @since 2013-2-21
 * @version 1.0
 * 
 * @update 2013-12-28 Zhou Xiaocong
 *   Use the class SourceCodeParser to parse all source files in a given path, and then modify the the constructor (i.e. NameTableCreator(String)) to
 *   create a SourceCodeParser for this.parser,, and modify the method create() to use this.parser to parse the source files in the path.   
 *   Moreover, add a constructor(i.e. NameTableCreator(SourceCodeParser)) to allow the client provide a SourceCodeParser to parse the source files, and
 *   delete the method loadFile(), parseSourceCode() and getAllJavaSourceFiles(), since their functions had been implemented in the class SourceCodeParser.
 */
public class NameTableCreator {
	
	protected NameTableManager table = null;
	protected String systemPath = null;
	protected SourceCodeParser parser = null;
	
	protected String currentUnitFullName = null;
	protected CompilationUnit currentASTRoot = null;
	private File currentFile = null;
	
	protected int errorUnitNumber = 0;
	protected PrintWriter errorReporter = new PrintWriter(System.out);
	
	protected TypeASTVisitor typeVisitor = new TypeASTVisitor(null, null, null);
	protected ExpressionASTVisitor expressionVisitor = new ExpressionASTVisitor(null, null, null);

	public NameTableCreator(SourceCodeParser parser) {
		this.parser = parser;
		systemPath = parser.getSystemPath();
		
		table = new NameTableManager(parser);
	}
	
	public NameTableCreator(String systemPath) {
		parser = new SourceCodeParser(systemPath);
		this.systemPath = parser.getSystemPath();
		table = new NameTableManager(parser);
	}

	/**
	 * <p>Create all name definitions and name reference in name table, and bind imports in all compilation units, and define all global name.
	 * i.e. the returned name table manager is ready for resolving name reference!
	 * 
	 * <p>The client should only use this method of a NameTableCreator!
	 */
	public NameTableManager createNameTableManager() {
		return createNameTableManager(false);
	}

	/**
	 * <p>Create all name definitions and name reference in name table, and bind imports in all compilation units, and define all global name.
	 * i.e. the returned name table manager is ready for resolving name reference! The flag 'collectDetailedInformation' indicates that if the 
	 * method should collect detailed information to debug file during creating the name table
	 * 
	 * <p>The client should only use this method of a NameTableCreator!
	 */
	public NameTableManager createNameTableManager(boolean collectDetailedInformation) {
		create(collectDetailedInformation);
		bindImportsInAllCompilationUnits();
		defineGlobalNames();
		
		return table;
	}
	
	public void setErrorReporter(PrintWriter reporter) {
		errorReporter = reporter;
	}
	
	public int getErrorUnitNumber() {
		return errorUnitNumber;
	}
	
	NameTableManager getNameTable() {
		return table;
	}
	
	/**
	 * Create all name definitions and name references of all Java source code files under the given path
	 */
	void create(boolean flag) {
		SystemScope currentScope = new SystemScope();
		table.setRootScope(currentScope);
		
		parser.toGetFirstParsedFile();
		while (parser.hasParsedFileInfo()) {
			currentASTRoot = parser.getCurrentCompilationUnit();
			if (parser.hasParseErrorInCurrentCompilationUnit()) {
				errorReporter.println(parser.getCurrentUnitFullName() + "\tParseringError");
				if (flag == true) errorReporter.println("\tError message: " + parser.getCurrentParseErrorMessage());
				currentASTRoot = null;
				errorUnitNumber = errorUnitNumber + 1;
			}
			if (currentASTRoot != null) {
				currentUnitFullName = parser.getCurrentUnitFullName();
				
				if (flag == true) errorReporter.println("Creating for file: " + currentUnitFullName);
				currentFile = parser.getCurrentFile();
				int typeNumber = scanCurrentCompilationUnit(currentScope);
				if (typeNumber <= 0) {
					errorReporter.println(parser.getCurrentUnitFullName() + "\tNoScannedType");
					if (flag == true) errorReporter.println("\tThere is no class, interface or enumeration types in file!");
				}
				parser.releaseCurrentCompilatinUnits();
				parser.releaseCurrentFileContents();
			}
			parser.toGetNextParsedFile();
		}
	}

	
	/**
	 * Bind imports in all compilation units to its type definition
	 */
	void bindImportsInAllCompilationUnits() {
		List<CompilationUnitScope> units = table.getAllCompilationUnitScopes();
		if (units == null) return;
		for (CompilationUnitScope unit : units) unit.bindImportDeclaration();
	}
	
	
	/**
	 * Scan current compilation unit to create name definitions and references
	 * CompilationUnit:
     *   [ PackageDeclaration ]
     *     { ImportDeclaration }
     *     { TypeDeclaration | EnumDeclaration | AnnotationTypeDeclaration | ; }
     * @pre-condition: currentSourceFileName ! = null &&  currentASTRoot != null
	 */
	@SuppressWarnings("unchecked")
	int scanCurrentCompilationUnit(SystemScope currentScope) {
		int scanedTypeNumber = 0;
		CompilationUnit node = currentASTRoot; 
		// 1. Process the package declaration in the unit
		PackageDeclaration packageDecl = node.getPackage();
		PackageDefinition packageDef = null;
		String packageName = null;
		if (packageDecl != null) {
			packageName = packageDecl.getName().getFullyQualifiedName();
			packageDef = currentScope.findPackageByName(packageName);
		} else {
			// The unit is in the unnamed package
			packageDef = currentScope.getUnnamedPackageDefinition();
		}
		if (packageDef == null) {
			// The package definition has not been add in the current scope!
			if (packageDecl != null) packageDef = new PackageDefinition(packageName);
			else packageDef = new PackageDefinition();
			// Define the package to the current scope
			currentScope.define(packageDef);
			packageDef.setScope(currentScope);

			// add the file's information about the package
			String filePath = currentFile.getAbsolutePath();
			if (packageName != null) {
				String packName = packageName.replace('.', '\\');
				int suffixIndex = filePath.lastIndexOf(packName);
				if (suffixIndex != -1) {
					String packAbsPath = filePath.substring(0, suffixIndex)
							+ packName;
					packageDef.bindPackageDir(new File(packAbsPath));
				}
			}
		}
		
		// 2 Create a compilation unit scope in the package
		CompilationUnitScope unitScope = new CompilationUnitScope(currentUnitFullName);
		unitScope.setPackage(packageDef);
		packageDef.addCompilationUnit(unitScope);
		
		// 3 Process the import declarations in the node
		List<ImportDeclaration> imports = node.imports();
		for (ImportDeclaration importDecl : imports) {
			// Scan an import declaration. So far we DO NOT treat a static import declaration!
			if (!importDecl.isStatic()) {
				if (importDecl.isOnDemand()) {
					// create package reference for on-demand-import declaration
					String name = importDecl.getName().getFullyQualifiedName();		// it will be name of a package!
					SourceCodeLocation location = getStartPosition(importDecl);
					PackageReference packageRef = new PackageReference(name, location, unitScope);
					unitScope.addImportDeclaration(packageRef);
					
					// We do not add type reference or package reference to the reference list of the scope!
				} else {
					// create type reference for single-type-import declaration
					String name = importDecl.getName().getFullyQualifiedName();		// it will be name of a class!
					SourceCodeLocation location = getStartPosition(importDecl);
					TypeReference type = new TypeReference(name, location, unitScope);
					unitScope.addImportDeclaration(type);
					
					// We do not add type reference or package reference to the reference list of the scope!
				}
			}
		}
		
		// 4 Process the list declarations in the node
		List<AbstractTypeDeclaration> types = node.types();
		
		for (AbstractTypeDeclaration type : types) {
			if (type.getNodeType() == ASTNode.TYPE_DECLARATION) {
				scan(packageName, (TypeDeclaration)type, unitScope);
				scanedTypeNumber++;
			} else if (type.getNodeType() == ASTNode.ENUM_DECLARATION) {
				scan(packageName, (EnumDeclaration)type, unitScope);
				scanedTypeNumber++;
			}
		}
		return scanedTypeNumber;
	}

	
	/**
	 * Scan a type declaration node to create name definitions and references
     * TypeDeclaration:
     *  [ Javadoc ] { Modifier } class Identifier
     *                   [ extends Type]
     *                   [ implements Type { , Type } ]
     *                   { { BodyDeclaration | ; } }
     *  BodyDeclaration: FieldDelcaration MethodDeclaration TypeDeclaration           
	 */
	@SuppressWarnings("unchecked")
	void scan(String qualifier, TypeDeclaration node, NameScope currentScope) {
		// Create a type definition for the node
		String name = node.getName().getFullyQualifiedName();
		String fullQualifiedName = (qualifier == null) ? name : qualifier + NameReferenceLabel.NAME_QUALIFIER + name;
		SourceCodeLocation location = getStartPosition(node);
		SourceCodeLocation endLocation = getEndPosition(node);
		DetailedTypeDefinition typeDef = new DetailedTypeDefinition(name, fullQualifiedName, location, currentScope, endLocation);
		typeDef.setCorrespondingFile(currentFile.getAbsolutePath());
		typeDef.setInterface(node.isInterface());
		typeDef.setPackageMember(node.isPackageMemberTypeDeclaration());
		typeDef.setModifierFlag(node.getModifiers());
		currentScope.define(typeDef);
		
		// Create type reference for the super class
		if (node.getSuperclassType() != null) {
			Type superClassType = node.getSuperclassType();
			typeVisitor.reset(currentUnitFullName, currentASTRoot, currentScope);
			superClassType.accept(typeVisitor);
			TypeReference superClassRef = typeVisitor.getResult();
			typeDef.addSuperType(superClassRef);
			// Add to the reference list in the current scope, which include the type definition
			currentScope.addReference(superClassRef);
		}
		// Create type reference for the super interfaces
		List<Type> superInterfaces = node.superInterfaceTypes();
		for (Type superInterface : superInterfaces) {
			typeVisitor.reset(currentUnitFullName, currentASTRoot, currentScope);
			superInterface.accept(typeVisitor);
			TypeReference superInterfaceRef = typeVisitor.getResult();
			typeDef.addSuperType(superInterfaceRef);
			// Add to the reference list in the current scope, which include the type definition
			currentScope.addReference(superInterfaceRef);
		}
	
		// Process the field declarations in the node
		FieldDeclaration[] fields = node.getFields();
		for (int index = 0; index < fields.length; index++) scan(fullQualifiedName, fields[index], typeDef);
		
		// Process the method declarations in the node
		MethodDeclaration[] methods = node.getMethods();
		for (int index = 0; index < methods.length; index++) scan(fullQualifiedName, methods[index], typeDef);
		
		// Automatically generated default constructor if this class has not any constructor
		boolean hasConstructor = false;
		List<MethodDefinition> methodList = typeDef.getMethodList();
		if (methodList == null) methodList = new ArrayList<MethodDefinition>();
		for (MethodDefinition method : methodList) {
			if (method.isConstructor()) hasConstructor = true;
		}
		if (!hasConstructor) {
			MethodDefinition defaultConstructor = new AutoGeneratedConstructor(name, fullQualifiedName, location, typeDef, location);
			methodList.add(defaultConstructor);
		}
		
		// Process the type declarations in the node
		AbstractTypeDeclaration[] typeMembers = node.getTypes(); 
		for (int index = 0; index < typeMembers.length; index++) {
			AbstractTypeDeclaration type = typeMembers[index];
			if (type.getNodeType() == ASTNode.TYPE_DECLARATION) {
				scan(fullQualifiedName, (TypeDeclaration)type, typeDef);
			} else if (type.getNodeType() == ASTNode.ENUM_DECLARATION) {
				scan(fullQualifiedName, (EnumDeclaration)type, typeDef);
			}
		}
	}

	/**
	 * Scan a enum declaration node to create name definitions and references
	 * EnumDeclaration:
     * 	[ Javadoc ] { ExtendedModifier } enum Identifier
     *	    [ implements Type { , Type } ]
     *	    {
     *	    	[ EnumConstantDeclaration { , EnumConstantDeclaration } ] [ , ]
     *	    	[ ; { ClassBodyDeclaration | ; } ]
     *	    }
	 */
	@SuppressWarnings("unchecked")
	void scan(String qualifier, EnumDeclaration node, NameScope currentScope) {
		// Create a type definition for the node
		String name = node.getName().getFullyQualifiedName();
		String fullQualifiedName = (qualifier == null) ? name : qualifier + NameReferenceLabel.NAME_QUALIFIER + name;
		SourceCodeLocation location = getStartPosition(node);
		SourceCodeLocation endLocation = getEndPosition(node);
		EnumTypeDefinition typeDef = new EnumTypeDefinition(name, fullQualifiedName, location, currentScope, endLocation);
		typeDef.setPackageMember(node.isPackageMemberTypeDeclaration());
		typeDef.setModifierFlag(node.getModifiers());
		currentScope.define(typeDef);
		
		// Create type reference for the super interfaces
		List<Type> superInterfaces = node.superInterfaceTypes();
		for (Type superInterface : superInterfaces) {
			typeVisitor.reset(currentUnitFullName, currentASTRoot, currentScope);
			superInterface.accept(typeVisitor);
			TypeReference superInterfaceRef = typeVisitor.getResult();
			typeDef.addSuperType(superInterfaceRef);
			// Add to the reference list in the current scope, which include the type definition
			currentScope.addReference(superInterfaceRef);
		}
		
		// Process the constant declarations in the node. We regard the enum constant as method 
		List<EnumConstantDeclaration> constants = node.enumConstants();
		for (EnumConstantDeclaration constant : constants) {
			scan(fullQualifiedName, constant, typeDef);
		}
	}

	/**
	 * Scan a field declaration node to create name definitions and references
	 * FieldDelcaration: [Javadoc] { ExtendedModifier } Type VariableDeclarationFragment
     *                       { , VariableDeclarationFragment } ;
	 */
	@SuppressWarnings("unchecked")
	void scan(String qualifier, FieldDeclaration node, NameScope currentScope) {
		// Get the type reference for the variable declaration
		Type type = node.getType();
		typeVisitor.reset(currentUnitFullName, currentASTRoot, currentScope);
		type.accept(typeVisitor);
		TypeReference typeRef = typeVisitor.getResult();
		// Add to the reference list in the currentScope, which include the field
		currentScope.addReference(typeRef);
		
		int modifierFlag = node.getModifiers();
		
		// Visit the variable list defined in the node
		List<VariableDeclarationFragment> fragments = node.fragments();
		for (VariableDeclarationFragment varNode : fragments) {
			// Define the variable to the current scope
			defineField(qualifier, varNode, typeRef, currentScope, modifierFlag);
			
			// Visit the initializer in the variable declaration
			Expression initializer = varNode.getInitializer();
			if (initializer != null) {
				expressionVisitor.reset(currentScope);
				initializer.accept(expressionVisitor);
				NameReference initExpRef = expressionVisitor.getResult();
				currentScope.addReference(initExpRef);
			}
		}
	}
	
	/**
	 * Scan a method declaration node to create name definitions and references
     *  [ Javadoc ] { ExtendedModifier }
     *              [ < TypeParameter { , TypeParameter } > ]
     *    ( Type | void ) Identifier (
     *    [ FormalParameter
     *                 { , FormalParameter } ] ) {[ ] }
     *   [ throws TypeName { , TypeName } ] ( Block | ; )
	 */
	@SuppressWarnings("unchecked")
	void scan(String qualifier, MethodDeclaration node, NameScope currentScope) {
		// Create type reference for the return type
		Type returnType = node.getReturnType2();
		TypeReference returnTypeRef = null;
		if (returnType != null) {
			typeVisitor.reset(currentUnitFullName, currentASTRoot, currentScope);
			returnType.accept(typeVisitor);
			returnTypeRef = typeVisitor.getResult();
			int dimension = returnTypeRef.getDimension() + node.getExtraDimensions();
			returnTypeRef.setDimension(dimension);
			
			// Add the reference to the reference list in the current scope, which include the method
			currentScope.addReference(returnTypeRef);
		} // else is a constructor 
		
		// Create method definition for the node
		String methodName = node.getName().getFullyQualifiedName();
		String fullQualifiedName = (qualifier == null) ? methodName : qualifier + NameReferenceLabel.NAME_QUALIFIER + methodName;
		SourceCodeLocation location = getStartPosition(node);
		SourceCodeLocation endLocation = getEndPosition(node);
		MethodDefinition methodDef = new MethodDefinition(methodName, fullQualifiedName, location, currentScope, endLocation);
		methodDef.setReturnType(returnTypeRef);
		methodDef.setModifierFlag(node.getModifiers());
		methodDef.setConstructor(node.isConstructor());
		currentScope.define(methodDef);

		// Debug.println("Scan method: " + methodName);
		
		// Create parameter definition for the node
		List<SingleVariableDeclaration> parameters = node.parameters();
		for (SingleVariableDeclaration parameter : parameters) {
			defineParameber(parameter, methodDef);
		}
		
		// Create type reference for throws type in the node
		@SuppressWarnings("deprecation")
		List<Name> throwTypes = node.thrownExceptions();
		for (Name throwType : throwTypes) {
			location = getStartPosition(throwType);
			TypeReference throwTypeRef = new TypeReference(throwType.getFullyQualifiedName(), location, currentScope);
			methodDef.addThrowTypes(throwTypeRef);

			// Add the reference to the reference list in the current scope, which include the method
			currentScope.addReference(returnTypeRef);
		}
		
		// Scan the body of the method
		Block body = node.getBody();
		if (body != null) {
			SourceCodeLocation start = getStartPosition(body);
			SourceCodeLocation end = getEndPosition(body);
			LocalScope localScope = createLocalScope(start, end, methodDef);
			methodDef.setBodyScope(localScope);
			// We can not reuse the block visitor for all methods, because when the method defines 
			// local types, and there are methods in the local types, we can not reuse the scope stack in 
			// the same block visitor! 
			BlockASTVisitor blockVisitor = new BlockASTVisitor(this, currentUnitFullName, currentASTRoot, localScope);
			// Then visit all children of the block
			List<Statement> statementList = body.statements();
			for (Statement statement : statementList) statement.accept(blockVisitor);
		}
	}

	@SuppressWarnings("unchecked")
	void scan(String qualifier, EnumConstantDeclaration node, NameScope currentScope) {
		String name = node.getName().getFullyQualifiedName();
		String fullQualifiedName = (qualifier == null) ? name : qualifier + NameReferenceLabel.NAME_QUALIFIER + name;
		SourceCodeLocation location = getStartPosition(node);
		
		EnumConstantDefinition constDef = new EnumConstantDefinition(name, fullQualifiedName, location, currentScope);
		currentScope.define(constDef);
		
		List<Expression> arguments = node.arguments();
		for (Expression argument : arguments) {
			expressionVisitor.reset(currentScope);
			argument.accept(expressionVisitor);
			NameReference argRef = expressionVisitor.getResult();
			constDef.addArgument(argRef);

			// Add the reference to the reference list in the current scope, which include the enum constant
			currentScope.addReference(argRef);
		}
	}
	
	/**
	 * Calculate the start source code location for a AST node
	 * @pre-condition: The node must be in the currentASTRoot
	 */
	SourceCodeLocation getStartPosition(ASTNode node) {
		return SourceCodeLocation.getStartLocation(node, currentASTRoot, currentUnitFullName);
	}

	/**
	 * Calculate the end source code location for a AST node
	 * @pre-condition: The node must be in the currentASTRoot
	 */
	SourceCodeLocation getEndPosition(ASTNode node) {
		return SourceCodeLocation.getEndLocation(node, currentASTRoot, currentUnitFullName);
	}
	
	/**
	 * Check whether a local scope is need to create for the block in the current compilation unit.
	 */
	@SuppressWarnings("unchecked")
	static boolean needCreateLocalScope(Block block) {
		boolean createLocalScope = false;
		List<Statement> statementList = block.statements();
		for (Statement statement : statementList) {
			int nodeType = statement.getNodeType();
			if (nodeType == ASTNode.TYPE_DECLARATION_STATEMENT || nodeType == ASTNode.VARIABLE_DECLARATION_STATEMENT) {
				createLocalScope = true;
				break;
			}
		}
		return createLocalScope;
	}
	
	/**
	 * Create a local scope for source codes from start location to the end location in the current compilation unit. The parent scope of 
	 * the new local scope is parent. 
	 * This method maintain the parent (i.e. enclosing) scope of the new scope, and the sub-scope list of the parent
	 * @return The new scope created by the method
	 */
	static LocalScope createLocalScope(SourceCodeLocation start, SourceCodeLocation end, NameScope parent) {
		LocalScope localScope = new LocalScope(parent);
		localScope.setEnclosingScope(parent);
		localScope.setScopeArea(start, end);
		if (parent.getScopeKind() == NameScopeKind.NSK_LOCAL) {
			LocalScope currScope = (LocalScope)parent;
			currScope.addSubLocalScope(localScope);
		} else if (parent.getScopeKind() != NameScopeKind.NSK_METHOD) {
			throw new AssertionError("The current scope must be a local scope when scan a block!");
		}
		return localScope;
	}
	
	/**
	 * Define a parameter in a SingleVariableDeclaration to the scope given by the parameter currentScope
	 */
	void defineParameber(SingleVariableDeclaration node, NameScope currentScope) {
		Type type = node.getType();
		typeVisitor.reset(currentUnitFullName, currentASTRoot, currentScope);
		type.accept(typeVisitor);
		TypeReference typeRef = typeVisitor.getResult();
		// Set the correct dimension for the variable 
		int dimension = typeRef.getDimension() + node.getExtraDimensions();
		typeRef.setDimension(dimension);

		// Add the reference to the reference list in the current scope, which include the parameter
		currentScope.addReference(typeRef);
		
		// Define the variable to the current scope
		String varName = node.getName().getFullyQualifiedName();
		SourceCodeLocation location = getStartPosition(node);
		VariableDefinition variableDef = new VariableDefinition(varName, varName, location, currentScope);
		variableDef.setVariableDefinitionKind(NameDefinitionKind.NDK_PARAMETER);
		variableDef.setType(typeRef);
		currentScope.define(variableDef);
	}

	
	/**
	 * Define a field in a VariableDeclaration to the scope given by the parameter currentScope
	 * The caller must to provide the type reference for the variable, since the the node may be a VariableDeclarationFragment
	 * Because the dimension of the node may be different from the other variables declared in the same variableDeclaration,
	 * we should copy the type reference for the variable definition of the node.
	 */
	void defineField(String qualifier, VariableDeclaration node, TypeReference varTypeRef, NameScope currentScope, int modifierFlag) {
		// And because the dimension of the node may be different from the other variables declared in the same variableDeclaration,
		// we should copy the type reference for the variable definition of the node.
		TypeReference typeRef = null;
		if (varTypeRef.isQualifiedType()) typeRef = new QualifiedTypeReference((QualifiedTypeReference)varTypeRef);
		else if (varTypeRef.isParameterizedType()) typeRef = new ParameterizedTypeReference((ParameterizedTypeReference)varTypeRef);
		else typeRef = new TypeReference(varTypeRef);

		// Set the correct dimension for the variable 
		int dimension = varTypeRef.getDimension() + node.getExtraDimensions();
		typeRef.setDimension(dimension);
		
		// Define the variable to the current scope
		String varName = node.getName().getFullyQualifiedName();
		String fullQualifiedName = (qualifier == null) ? varName : qualifier + NameReferenceLabel.NAME_QUALIFIER + varName;
		SourceCodeLocation location = getStartPosition(node);
		FieldDefinition fieldDef = new FieldDefinition(varName, fullQualifiedName, location, currentScope);
		fieldDef.setType(typeRef);
		fieldDef.setModifierFlag(modifierFlag);
		currentScope.define(fieldDef);
	}
	
	/**
	 * Define a variable in a VariableDeclaration to the scope given by the parameter currentScope
	 * The caller must to provide the type reference for the variable, since the the node may be a VariableDeclarationFragment
	 * Because the dimension of the node may be different from the other variables declared in the same variableDeclaration,
	 * we should copy the type reference for the variable definition of the node.
	 */
	static void defineVariable(VariableDeclaration node, TypeReference varTypeRef, NameScope currentScope, String unitFullName, CompilationUnit root) {
		// And because the dimension of the node may be different from the other variables declared in the same variableDeclaration,
		// we should copy the type reference for the variable definition of the node.
		TypeReference typeRef = null;
		if (varTypeRef.isQualifiedType()) typeRef = new QualifiedTypeReference((QualifiedTypeReference)varTypeRef);
		else if (varTypeRef.isParameterizedType()) typeRef = new ParameterizedTypeReference((ParameterizedTypeReference)varTypeRef);
		else typeRef = new TypeReference(varTypeRef);
		
		// Set the correct dimension for the variable 
		int dimension = varTypeRef.getDimension() + node.getExtraDimensions();
		typeRef.setDimension(dimension);
		
		// Define the variable to the current scope
		String varName = node.getName().getFullyQualifiedName();
		SourceCodeLocation location = SourceCodeLocation.getStartLocation(node, root, unitFullName);
		VariableDefinition variableDef = new VariableDefinition(varName, varName, location, currentScope);
		variableDef.setType(typeRef);
		currentScope.define(variableDef);
	}
	
	

	/**
	 * Define all primitive type and some class name in java.lang to the system scope
	 */
	void defineGlobalNames() {
		String[][] primitiveTypeName = {
				{NameReferenceLabel.TYPE_BOOLEAN, NameReferenceLabel.TYPE_BOOLEAN},
				{NameReferenceLabel.TYPE_BYTE, NameReferenceLabel.TYPE_BYTE},
				{NameReferenceLabel.TYPE_CHAR, NameReferenceLabel.TYPE_CHAR},
				{NameReferenceLabel.TYPE_DOUBLE, NameReferenceLabel.TYPE_DOUBLE},
				{NameReferenceLabel.TYPE_FLOAT, NameReferenceLabel.TYPE_FLOAT},
				{NameReferenceLabel.TYPE_INT, NameReferenceLabel.TYPE_INT},
				{NameReferenceLabel.TYPE_LONG, NameReferenceLabel.TYPE_LONG},
				{NameReferenceLabel.TYPE_SHORT, NameReferenceLabel.TYPE_SHORT},
				{NameReferenceLabel.TYPE_VOID, NameReferenceLabel.TYPE_VOID},
		};
		String[][] systemName = {
				{NameReferenceLabel.TYPE_STRING, "java.lang." + NameReferenceLabel.TYPE_STRING},
				{NameReferenceLabel.TYPE_CLASS, "java.lang." + NameReferenceLabel.TYPE_CLASS},
				{"Object", "java.lang.Object"},
				{"System", "java.lang.System"},
				{"StringBuffer", "java.lang.StringBuffer"},
				{"StringBuilder", "java.lang.StringBuilder"},
				{"Math", "java.lang.Math"},
				{"Exception", "java.lang.Exception"},
				{"AssertionError", "java.lang.AssertionError"},
				{"Boolean", "java.lang.Boolean"},
				{"Character", "java.lang.Character"},
				{"CharSequence", "java.lang.CharSequence"},
				{"Number", "java.lang.Number"},
				{"Byte", "java.lang.Byte"},
				{"Short", "java.lang.Short"},
				{"Integer", "java.lang.Integer"},
				{"Long", "java.lang.Long"},
				{"Float", "java.lang.Float"},
				{"Double", "java.lang.Double"},
				{"Void", "java.lang.Void"},
				{"StringCoding", "java.lang.StringCoding"},
				{"StringValue", "java.lang.StringValue"},
				{"Runtime", "java.lang.Runtime"},
				{"Thread", "java.lang.Thread"},
				{"ThreadGroup", "java.lang.ThreadGroup"},
				{"ClassLoader", "java.lang.ClassLoader"},
				{"Package", "java.lang.Package"},
				{"Process", "java.lang.Process"},
				{"Comparable", "java.lang.Comparable"},
				{"Runnable", "java.lang.Runnable"},
				{"Throwable", "java.lang.Throwable"},
				{"Cloneable", "java.lang.Cloneable"},
				{"Comparable", "java.lang.Comparable"},
				{"Iterable", "java.lang.Iterable"},
		};
		
		SystemScope currentScope = table.getRootScope();
		for (int index = 0; index < primitiveTypeName.length; index++) {
			SimpleTypeDefinition name = new SimpleTypeDefinition(primitiveTypeName[index][0], primitiveTypeName[index][1], currentScope);
			currentScope.define(name);
		}
		
		PackageDefinition systemPackage = currentScope.findPackageByName(SystemScope.SYSTEM_PACKAGE_NAME);
		if (systemPackage == null) {
			for (int index = 0; index < systemName.length; index++) {
				SimpleTypeDefinition name = new SimpleTypeDefinition(systemName[index][0], systemName[index][1], currentScope);
				currentScope.define(name);
			}
		}
	}
}
